import { useId as Ae, provide as T, computed as A, reactive as le, watch as k, onMounted as R, ref as U, inject as $, nextTick as G, shallowRef as te, onBeforeUnmount as ne, toRef as Re, defineComponent as ce, createVNode as O, Fragment as He } from "vue";
import { deepMerge as Me, deepClone as Pe, randomId as ie, debounce as Le } from "@vavt/util";
import { p as h, g as M, f as ue, s as me, b as _e, a as Oe } from "./config.mjs";
import { b as y, U as Ne, C as Ee, B as X, O as Te, E as Q, P as fe, F as he, f as pe, g as ge, H as ve, h as ye, R as se, e as je, i as de, d as Be, j as ae, k as De, T as Ve } from "./event-bus.mjs";
import { a as L, u as Ue, S as Ge, c as ze, z as We } from "./dom.mjs";
import qe from "@vavt/copy2clipboard";
import Ke from "markdown-it";
import Ze from "markdown-it-image-figures";
import Je from "markdown-it-sub";
import Xe from "markdown-it-sup";
import { g as Ye } from "./index5.mjs";
import { LRUCache as Qe } from "lru-cache";
import et from "medium-zoom";
const P = {
  hljs: `${h}-hljs`,
  hlcss: `${h}-hlCss`,
  prettier: `${h}-prettier`,
  prettierMD: `${h}-prettierMD`,
  cropperjs: `${h}-cropper`,
  croppercss: `${h}-cropperCss`,
  screenfull: `${h}-screenfull`,
  mermaidM: `${h}-mermaid-m`,
  mermaid: `${h}-mermaid`,
  katexjs: `${h}-katex`,
  katexcss: `${h}-katexCss`,
  echarts: `${h}-echarts`
}, Zt = (e, t, r) => {
  const { editorId: n } = r, o = le({
    // 是否已编译成html
    buildFinished: !1,
    // 存储当前最新的html
    html: ""
  });
  k(
    () => e.modelValue,
    () => {
      o.buildFinished = !1;
    }
  ), R(() => {
    y.on(n, {
      name: X,
      callback(m) {
        o.buildFinished = !0, o.html = m;
      }
    }), y.on(n, {
      name: Te,
      callback() {
        const m = new Promise((d) => {
          if (o.buildFinished)
            d(o.html);
          else {
            const c = (i) => {
              d(i), y.remove(n, X, c);
            };
            y.on(n, {
              name: X,
              callback: c
            });
          }
        });
        e.onSave ? e.onSave(e.modelValue, m) : t.emit("onSave", e.modelValue, m);
      }
    });
  });
}, Ie = (e, {
  editorId: t,
  rootRef: r,
  setting: n
}) => {
  const o = M.editorExtensions.highlight, m = M.editorExtensionsAttrs.highlight;
  T("editorId", t), T("rootRef", r), T(
    "theme",
    A(() => e.theme)
  ), T(
    "language",
    A(() => e.language)
  ), T(
    "highlight",
    A(() => {
      const { js: c } = o, i = {
        ...ue,
        ...o.css
      }, { js: u, css: l = {} } = m || {}, a = e.codeStyleReverse && e.codeStyleReverseList.includes(e.previewTheme) ? "dark" : e.theme, s = i[e.codeTheme] ? i[e.codeTheme][a] : ue.atom[a], g = i[e.codeTheme] && l[e.codeTheme] ? l[e.codeTheme][a] : l.atom ? l.atom[a] : {};
      return {
        js: {
          src: c,
          ...u
        },
        css: {
          href: s,
          ...g
        }
      };
    })
  ), T("showCodeRowNumber", e.showCodeRowNumber);
  const d = A(() => {
    const c = {
      ...me,
      ...M.editorConfig.languageUserDefined
    };
    return Me(
      Pe(me["en-US"]),
      c[e.language] || {}
    );
  });
  return T("usedLanguageText", d), T(
    "previewTheme",
    A(() => e.previewTheme)
  ), T(
    "customIcon",
    A(() => e.customIcon)
  ), T(
    "setting",
    A(() => n ? {
      // setting是reactive，不转化是可以直接赋值的
      ...n
    } : {
      preview: !0,
      htmlPreview: !1,
      previewOnly: !1,
      pageFullscreen: !1,
      fullscreen: !1
    })
  ), { editorId: t };
}, Jt = (e, t) => (T("tabWidth", e.tabWidth), T(
  "disabled",
  A(() => e.disabled)
), T(
  "showToolbarName",
  A(() => e.showToolbarName)
), T("noUploadImg", e.noUploadImg), T(
  "tableShape",
  A(() => e.tableShape)
), T("noPrettier", e.noPrettier), T(
  "codeTheme",
  A(() => e.codeTheme)
), T("updateSetting", t.updateSetting), T(
  "catalogVisible",
  A(() => t.catalogVisible.value)
), T("defToolbars", t.defToolbars), T(
  "floatingToolbars",
  A(() => e.floatingToolbars)
), Ie(e, t)), Xt = (e) => {
  const { noPrettier: t, noUploadImg: r } = e, { editorExtensions: n, editorExtensionsAttrs: o } = M, m = t || n.prettier.prettierInstance, d = t || n.prettier.parserMarkdownInstance, c = r || n.cropper.instance;
  R(() => {
    if (!c) {
      const { js: i = {}, css: u = {} } = o.cropper || {};
      L("link", {
        ...u,
        rel: "stylesheet",
        href: n.cropper.css,
        id: P.croppercss
      }), L("script", {
        ...i,
        src: n.cropper.js,
        id: P.cropperjs
      });
    }
    if (!m) {
      const { standaloneJs: i = {} } = o.prettier || {};
      L("script", {
        ...i,
        src: n.prettier.standaloneJs,
        id: P.prettier
      });
    }
    if (!d) {
      const { parserMarkdownJs: i = {} } = o.prettier || {};
      L("script", {
        ...i,
        src: n.prettier.parserMarkdownJs,
        id: P.prettierMD
      });
    }
  });
}, Yt = (e, t, r) => {
  const { editorId: n } = r;
  R(() => {
    y.on(n, {
      name: Q,
      callback: (o) => {
        e.onError?.(o), t.emit("onError", o);
      }
    });
  });
}, Qt = (e, t, r) => {
  const { editorId: n } = r, o = le({
    pageFullscreen: e.pageFullscreen,
    fullscreen: !1,
    preview: e.preview,
    htmlPreview: e.preview ? !1 : e.htmlPreview,
    previewOnly: !1
  }), m = le({ ...o }), d = (u, l) => {
    const a = l === void 0 ? !o[u] : l;
    switch (u) {
      case "preview": {
        o.htmlPreview = !1, o.previewOnly = !1;
        break;
      }
      case "htmlPreview": {
        o.preview = !1, o.previewOnly = !1;
        break;
      }
      case "previewOnly": {
        a ? !o.preview && !o.htmlPreview && (o.preview = !0) : (m.preview || (o.preview = !1), m.htmlPreview || (o.htmlPreview = !1));
        break;
      }
    }
    m[u] = a, o[u] = a;
  };
  let c = "";
  const i = () => {
    o.pageFullscreen || o.fullscreen ? document.body.style.overflow = "hidden" : document.body.style.overflow = c;
  };
  return k(() => [o.pageFullscreen, o.fullscreen], i), R(() => {
    y.on(n, {
      name: Ne,
      callback(u, l) {
        const a = (s) => {
          y.emit(n, se, "image", {
            desc: "",
            urls: s
          }), l?.();
        };
        e.onUploadImg ? e.onUploadImg(u, a) : t.emit("onUploadImg", u, a);
      }
    }), c = document.body.style.overflow, i();
  }), [o, d];
}, en = (e, t) => {
  const { editorId: r } = t, n = U(!1);
  return R(() => {
    y.on(r, {
      name: Ee,
      callback: (o) => {
        o === void 0 ? n.value = !n.value : n.value = o;
      }
    });
  }), n;
}, tn = (e, t, r) => {
  const { editorId: n, catalogVisible: o, setting: m, updateSetting: d, codeRef: c } = r;
  k(
    () => m.pageFullscreen,
    (u) => {
      y.emit(n, fe, u);
    }
  ), k(
    () => m.fullscreen,
    (u) => {
      y.emit(n, he, u);
    }
  ), k(
    () => m.preview,
    (u) => {
      y.emit(n, pe, u);
    }
  ), k(
    () => m.previewOnly,
    (u) => {
      y.emit(n, ge, u);
    }
  ), k(
    () => m.htmlPreview,
    (u) => {
      y.emit(n, ve, u);
    }
  ), k(o, (u) => {
    y.emit(n, ye, u);
  });
  const i = {
    on(u, l) {
      switch (u) {
        case "pageFullscreen": {
          y.on(n, {
            name: fe,
            callback(a) {
              l(a);
            }
          });
          break;
        }
        case "fullscreen": {
          y.on(n, {
            name: he,
            callback(a) {
              l(a);
            }
          });
          break;
        }
        case "preview": {
          y.on(n, {
            name: pe,
            callback(a) {
              l(a);
            }
          });
          break;
        }
        case "previewOnly": {
          y.on(n, {
            name: ge,
            callback(a) {
              l(a);
            }
          });
          break;
        }
        case "htmlPreview": {
          y.on(n, {
            name: ve,
            callback(a) {
              l(a);
            }
          });
          break;
        }
        case "catalog": {
          y.on(n, {
            name: ye,
            callback(a) {
              l(a);
            }
          });
          break;
        }
      }
    },
    togglePageFullscreen(u) {
      d("pageFullscreen", u);
    },
    toggleFullscreen(u) {
      y.emit(n, Be, u);
    },
    togglePreview(u) {
      d("preview", u);
    },
    togglePreviewOnly(u) {
      d("previewOnly", u);
    },
    toggleHtmlPreview(u) {
      d("htmlPreview", u);
    },
    toggleCatalog(u) {
      y.emit(n, Ee, u);
    },
    triggerSave() {
      y.emit(n, Te);
    },
    insert(u) {
      y.emit(n, se, "universal", { generate: u });
    },
    focus(u) {
      c.value?.focus(u);
    },
    rerender() {
      y.emit(n, de);
    },
    getSelectedText() {
      return c.value?.getSelectedText();
    },
    resetHistory() {
      c.value?.resetHistory();
    },
    domEventHandlers(u) {
      y.emit(n, je, u);
    },
    execCommand(u) {
      y.emit(n, se, u);
    },
    getEditorView() {
      return c.value?.getEditorView();
    }
  };
  t.expose(i);
}, tt = (e) => {
  const t = Ae();
  return e.id || e.editorId || `${h}-${t}`;
}, nt = (e, t, r) => {
  const n = $("editorId"), o = $("rootRef"), m = $("usedLanguageText"), d = $("setting"), c = () => {
    o.value.querySelectorAll(`#${n} .${h}-preview .${h}-code`).forEach((l) => {
      let a = -1;
      const s = l.querySelector(
        `.${h}-copy-button:not([data-processed])`
      );
      s && (s.onclick = (g) => {
        g.preventDefault(), clearTimeout(a);
        const p = (l.querySelector("input:checked + pre code") || l.querySelector("pre code")).textContent, { text: b, successTips: S, failTips: v } = m.value.copyCode;
        let C = S;
        qe(e.formatCopiedText(p || "")).catch(() => {
          C = v;
        }).finally(() => {
          s.dataset.isIcon ? s.dataset.tips = C : s.innerHTML = C, a = window.setTimeout(() => {
            s.dataset.isIcon ? s.dataset.tips = b : s.innerHTML = b;
          }, 1500);
        });
      }, s.setAttribute("data-processed", "true"));
    });
  }, i = () => {
    G(c);
  }, u = (l) => {
    l && G(c);
  };
  k([t, r], i), k(() => d.value.preview, u), k(() => d.value.htmlPreview, u), R(c);
}, ot = (e) => {
  const t = $("editorId"), r = $("theme"), n = $("rootRef"), { editorExtensions: o, editorExtensionsAttrs: m } = M;
  let d = o.echarts.instance;
  const c = te(-1), i = () => {
    !e.noEcharts && d && (c.value = c.value + 1);
  };
  k(
    () => r.value,
    () => {
      i();
    }
  ), R(() => {
    if (e.noEcharts || d)
      return;
    const f = o.echarts.js;
    L(
      "script",
      {
        ...m.echarts?.js,
        src: f,
        id: P.echarts,
        onload() {
          d = window.echarts, i();
        }
      },
      "echarts"
    );
  });
  let u = [], l = [], a = [];
  const s = (f = !1) => {
    if (!u.length) {
      f && (l.forEach((v) => {
        v.dispose?.();
      }), a.forEach((v) => {
        v.disconnect?.();
      }), l = [], a = []);
      return;
    }
    const p = [], b = [], S = [];
    u.forEach((v, C) => {
      const x = l[C], w = a[C];
      if (f || !v || !v.isConnected || (n?.value ? !n.value.contains(v) : !1)) {
        x?.dispose?.(), w?.disconnect?.();
        return;
      }
      p.push(v), x && b.push(x), w && S.push(w);
    }), u = p, l = b, a = S;
  }, g = () => {
    s(), !e.noEcharts && d && Array.from(
      n.value.querySelectorAll(
        `#${t} div.${h}-echarts:not([data-processed])`
      )
    ).forEach((p) => {
      if (p.dataset.closed === "false")
        return !1;
      try {
        const b = new Function(`return ${p.innerText}`)(), S = d.init(p, r.value);
        S.setOption(b), p.setAttribute("data-processed", ""), u.push(p), l.push(S);
        const v = new ResizeObserver(() => {
          S.resize();
        });
        v.observe(p), a.push(v);
      } catch (b) {
        y.emit(t, Q, {
          name: "echarts",
          message: b?.message,
          error: b
        });
      }
    });
  };
  return ne(() => {
    s(!0);
  }), { reRenderEcharts: c, replaceEcharts: g };
}, at = (e) => {
  const t = $("highlight"), r = te(M.editorExtensions.highlight.instance);
  return R(() => {
    e.noHighlight || r.value || (L("link", {
      ...t.value.css,
      rel: "stylesheet",
      id: P.hlcss
    }), L(
      "script",
      {
        ...t.value.js,
        id: P.hljs,
        onload() {
          r.value = window.hljs;
        }
      },
      "hljs"
    ));
  }), k(
    () => t.value.css,
    () => {
      e.noHighlight || M.editorExtensions.highlight.instance || Ue("link", {
        ...t.value.css,
        rel: "stylesheet",
        id: P.hlcss
      });
    }
  ), r;
}, rt = (e) => {
  const t = te(M.editorExtensions.katex.instance);
  return R(() => {
    if (e.noKatex || t.value)
      return;
    const { editorExtensions: r, editorExtensionsAttrs: n } = M;
    L(
      "script",
      {
        ...n.katex?.js,
        src: r.katex.js,
        id: P.katexjs,
        onload() {
          t.value = window.katex;
        }
      },
      "katex"
    ), L("link", {
      ...n.katex?.css,
      rel: "stylesheet",
      href: r.katex.css,
      id: P.katexcss
    });
  }), t;
}, Y = new Qe({
  max: 1e3,
  // 缓存10分钟
  ttl: 6e5
}), lt = (e) => {
  const t = $("editorId"), r = $("theme"), n = $("rootRef"), { editorExtensions: o, editorExtensionsAttrs: m, mermaidConfig: d } = M;
  let c = o.mermaid.instance;
  const i = te(-1), u = () => {
    !e.noMermaid && c && (c.initialize(
      d({
        startOnLoad: !1,
        theme: r.value === "dark" ? "dark" : "default"
      })
    ), i.value = i.value + 1);
  };
  return k(
    () => r.value,
    () => {
      Y.clear(), u();
    }
  ), R(() => {
    if (e.noMermaid || c)
      return;
    const a = o.mermaid.js;
    /\.mjs/.test(a) ? (L("link", {
      ...m.mermaid?.js,
      rel: "modulepreload",
      href: a,
      id: P.mermaidM
    }), import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      a
    ).then((s) => {
      c = s.default, u();
    }).catch((s) => {
      y.emit(t, Q, {
        name: "mermaid",
        message: `Failed to load mermaid module: ${s.message}`,
        error: s
      });
    })) : L(
      "script",
      {
        ...m.mermaid?.js,
        src: a,
        id: P.mermaid,
        onload() {
          c = window.mermaid, u();
        }
      },
      "mermaid"
    );
  }), { reRenderRef: i, replaceMermaid: async () => {
    if (!e.noMermaid && c) {
      const a = n.value.querySelectorAll(
        `div.${h}-mermaid`
      ), s = document.createElement("div"), g = document.body.offsetWidth > 1366 ? document.body.offsetWidth : 1366, f = document.body.offsetHeight > 768 ? document.body.offsetHeight : 768;
      s.style.width = g + "px", s.style.height = f + "px", s.style.position = "fixed", s.style.zIndex = "-10000", s.style.top = "-10000";
      let p = a.length;
      p > 0 && document.body.appendChild(s), await Promise.allSettled(
        Array.from(a).map((b) => (async (v) => {
          if (v.dataset.closed === "false")
            return !1;
          const C = v.innerText;
          let x = Y.get(C);
          if (!x) {
            const w = ie();
            let H = { svg: "" };
            try {
              H = await c.render(w, C, s), x = await e.sanitizeMermaid(H.svg);
              const I = document.createElement("p");
              I.className = `${h}-mermaid`, I.setAttribute("data-processed", ""), I.setAttribute("data-content", C), I.innerHTML = x, I.children[0]?.removeAttribute("height"), Y.set(C, I.innerHTML), v.dataset.line !== void 0 && (I.dataset.line = v.dataset.line), v.replaceWith(I);
            } catch (I) {
              y.emit(t, Q, {
                name: "mermaid",
                message: I.message,
                error: I
              });
            }
            --p === 0 && s.remove();
          }
        })(b))
      );
    }
  } };
}, it = (e, t) => {
  t = t || {};
  const r = 3, n = t.marker || "!", o = n.charCodeAt(0), m = n.length;
  let d = "", c = "";
  const i = (l, a, s, g, f) => {
    const p = l[a];
    return p.type === "admonition_open" ? l[a].attrPush([
      "class",
      `${h}-admonition ${h}-admonition-${p.info}`
    ]) : p.type === "admonition_title_open" && l[a].attrPush(["class", `${h}-admonition-title`]), f.renderToken(l, a, s);
  }, u = (l) => {
    const a = l.trim().split(" ", 2);
    c = "", d = a[0], a.length > 1 && (c = l.substring(d.length + 2));
  };
  e.block.ruler.before(
    "code",
    "admonition",
    (l, a, s, g) => {
      let f, p, b, S = !1, v = l.bMarks[a] + l.tShift[a], C = l.eMarks[a];
      if (o !== l.src.charCodeAt(v))
        return !1;
      for (f = v + 1; f <= C && n[(f - v) % m] === l.src[f]; f++)
        ;
      const x = Math.floor((f - v) / m);
      if (x !== r)
        return !1;
      f -= (f - v) % m;
      const w = l.src.slice(v, f), H = l.src.slice(f, C);
      if (u(H), g)
        return !0;
      for (p = a; p++, !(p >= s || (v = l.bMarks[p] + l.tShift[p], C = l.eMarks[p], v < C && l.sCount[p] < l.blkIndent)); )
        if (o === l.src.charCodeAt(v) && !(l.sCount[p] - l.blkIndent >= 4)) {
          for (f = v + 1; f <= C && n[(f - v) % m] === l.src[f]; f++)
            ;
          if (!(Math.floor((f - v) / m) < x) && (f -= (f - v) % m, f = l.skipSpaces(f), !(f < C))) {
            S = !0;
            break;
          }
        }
      const I = l.parentType, _ = l.lineMax;
      return l.parentType = "root", l.lineMax = p, b = l.push("admonition_open", "div", 1), b.markup = w, b.block = !0, b.info = d, b.map = [a, p], c && (b = l.push("admonition_title_open", "p", 1), b.markup = w + " " + d, b.map = [a, p], b = l.push("inline", "", 0), b.content = c, b.map = [a, l.line - 1], b.children = [], b = l.push("admonition_title_close", "p", -1), b.markup = w + " " + d), l.md.block.tokenize(l, a + 1, p), b = l.push("admonition_close", "div", -1), b.markup = l.src.slice(v, f), b.block = !0, l.parentType = I, l.lineMax = _, l.line = p + (S ? 1 : 0), !0;
    },
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  ), e.renderer.rules.admonition_open = i, e.renderer.rules.admonition_title_open = i, e.renderer.rules.admonition_title_close = i, e.renderer.rules.admonition_close = i;
}, ee = (e, t) => {
  const r = e.attrs ? e.attrs.slice() : [];
  return t.forEach((n) => {
    const o = e.attrIndex(n[0]);
    o < 0 ? r.push(n) : (r[o] = r[o].slice(), r[o][1] += ` ${n[1]}`);
  }), r;
}, st = (e, t) => {
  const r = e.renderer.rules.fence, n = e.utils.unescapeAll, o = /\[(\w*)(?::([\w ]*))?\]/, m = /::(open|close)/, d = (a) => a.info ? n(a.info).trim() : "", c = (a) => {
    const s = d(a), [g = null, f = ""] = (o.exec(s) || []).slice(1);
    return [g, f];
  }, i = (a) => {
    const s = d(a);
    return s ? s.split(/(\s+)/g)[0] : "";
  }, u = (a) => {
    const s = a.info.match(m) || [], g = s[1] === "open" || s[1] !== "close" && t.codeFoldable && a.content.trim().split(`
`).length < t.autoFoldThreshold, f = s[1] || t.codeFoldable ? "details" : "div", p = s[1] || t.codeFoldable ? "summary" : "div";
    return { open: g, tagContainer: f, tagHeader: p };
  }, l = (a, s, g, f, p) => {
    if (a[s].hidden)
      return "";
    const b = t.usedLanguageTextRef.value?.copyCode.text, S = t.customIconRef.value.copy || b, v = !!t.customIconRef.value.copy, C = `<span class="${h}-collapse-tips">${Ge("collapse-tips", t.customIconRef.value)}</span>`, [x] = c(a[s]);
    if (x === null) {
      const { open: E, tagContainer: F, tagHeader: J } = u(a[s]), j = [["class", `${h}-code`]];
      E && j.push(["open", ""]);
      const oe = {
        attrs: ee(a[s], j)
      };
      a[s].info = a[s].info.replace(m, "");
      const W = r(a, s, g, f, p);
      return `
        <${F} ${p.renderAttrs(oe)}>
          <${J} class="${h}-code-head">
            <div class="${h}-code-flag"><span></span><span></span><span></span></div>
            <div class="${h}-code-action">
              <span class="${h}-code-lang">${e.utils.escapeHtml(a[s].info.trim())}</span>
              <span class="${h}-copy-button" data-tips="${b}"${v ? " data-is-icon=true" : ""}>${S}</span>
              ${t.extraTools instanceof Function ? t.extraTools({ lang: a[s].info.trim() }) : t.extraTools || ""}
              ${F === "details" ? C : ""}
            </div>
          </${J}>
          ${W}
        </${F}>
      `;
    }
    let w, H, I, _, N = "", B = "", D = "";
    const { open: q, tagContainer: V, tagHeader: z } = u(a[s]), K = [["class", `${h}-code`]];
    q && K.push(["open", ""]);
    const Z = {
      attrs: ee(a[s], K)
    };
    for (let E = s; E < a.length && (w = a[E], [H, I] = c(w), H === x); E++) {
      w.info = w.info.replace(o, "").replace(m, ""), w.hidden = !0;
      const F = `${h}-codetab-${t.editorId}-${s}-${E - s}`;
      _ = E - s > 0 ? "" : "checked", N += `
        <li>
          <input
            type="radio"
            id="label-${h}-codetab-label-1-${t.editorId}-${s}-${E - s}"
            name="${h}-codetab-label-${t.editorId}-${s}"
            class="${F}"
            ${_}
          >
          <label
            for="label-${h}-codetab-label-1-${t.editorId}-${s}-${E - s}"
            onclick="this.getRootNode().querySelectorAll('.${F}').forEach(e => e.click())"
          >
            ${e.utils.escapeHtml(I || i(w))}
          </label>
        </li>`, B += `
        <div role="tabpanel">
          <input
            type="radio"
            name="${h}-codetab-pre-${t.editorId}-${s}"
            class="${F}"
            ${_}
            role="presentation">
          ${r(a, E, g, f, p)}
        </div>`, D += `
        <input
          type="radio"
          name="${h}-codetab-lang-${t.editorId}-${s}"
          class="${F}"
          ${_}
          role="presentation">
        <span class=${h}-code-lang role="note">${e.utils.escapeHtml(i(w))}</span>`;
    }
    return `
      <${V} ${p.renderAttrs(Z)}>
        <${z} class="${h}-code-head">
          <div class="${h}-code-flag">
            <ul class="${h}-codetab-label" role="tablist">${N}</ul>
          </div>
          <div class="${h}-code-action">
            <span class="${h}-codetab-lang">${D}</span>
            <span class="${h}-copy-button" data-tips="${b}"${v ? " data-is-icon=true" : ""}>${S}</span>
            ${t.extraTools instanceof Function ? t.extraTools({ lang: a[s].info.trim() }) : t.extraTools || ""}
            ${V === "details" ? C : ""}
          </div>
        </${z}>
        ${B}
      </${V}>
    `;
  };
  e.renderer.rules.fence = l, e.renderer.rules.code_block = l;
}, ct = (e, t) => {
  const r = e.renderer.rules.fence.bind(e.renderer.rules);
  e.renderer.rules.fence = (n, o, m, d, c) => {
    const i = n[o], u = i.content.trim();
    if (i.info === "echarts") {
      if (i.attrSet("class", `${h}-echarts`), i.attrSet("data-echarts-theme", t.themeRef.value), i.map && i.level === 0) {
        const l = i.map[1] - 1, s = !!d.srcLines[l]?.trim()?.startsWith("```");
        i.attrSet("data-closed", `${s}`), i.attrSet("data-line", String(i.map[0]));
      }
      return `<div ${c.renderAttrs(i)} style="width: 100%; aspect-ratio: 4 / 3;">${e.utils.escapeHtml(u)}</div>`;
    }
    return r(n, o, m, d, c);
  };
}, dt = (e, t) => {
  e.renderer.rules.heading_open = (r, n) => {
    const o = r[n], m = r[n + 1].children?.reduce((c, i) => c + (["text", "code_inline", "math_inline"].includes(i.type) && i.content || ""), "") || "", d = o.markup.length;
    return t.headsRef.value.push({
      text: m,
      level: d,
      line: o.map[0],
      currentToken: o,
      nextToken: r[n + 1]
    }), o.map && o.level === 0 && o.attrSet(
      "id",
      t.mdHeadingId({
        text: m,
        level: d,
        index: t.headsRef.value.length,
        currentToken: o,
        nextToken: r[n + 1]
      })
    ), e.renderer.renderToken(r, n, t);
  }, e.renderer.rules.heading_close = (r, n, o, m, d) => d.renderToken(r, n, o);
}, be = {
  block: [
    { open: "$$", close: "$$" },
    { open: "\\[", close: "\\]" }
  ],
  inline: [
    { open: "$$", close: "$$" },
    { open: "$", close: "$" },
    { open: "\\[", close: "\\]" },
    { open: "\\(", close: "\\)" }
  ]
}, ut = (e) => (t, r) => {
  const n = e.delimiters;
  let o, m, d;
  for (const c of n)
    if (t.src.startsWith(c.open, t.pos)) {
      const i = t.pos + c.open.length;
      for (o = i; (o = t.src.indexOf(c.close, o)) !== -1; ) {
        for (d = o - 1; t.src[d] === "\\"; )
          d -= 1;
        if ((o - d) % 2 === 1)
          break;
        o += c.close.length;
      }
      if (o === -1)
        return r || (t.pending += c.open), t.pos = i, !0;
      if (o - i === 0)
        return r || (t.pending += c.open + c.close), t.pos = i + c.close.length, !0;
      if (!r) {
        const u = t.src.slice(i, o);
        m = t.push("math_inline", "math", 0), m.markup = c.open, m.content = u;
      }
      return t.pos = o + c.close.length, !0;
    }
  return !1;
}, mt = (e) => (t, r, n, o) => {
  const m = e.delimiters;
  let d, c, i, u, l = !1, a = t.bMarks[r] + t.tShift[r], s = t.eMarks[r];
  for (const g of m)
    if (t.src.slice(a, a + g.open.length) === g.open && t.src.slice(s - g.close.length, s) === g.close) {
      if (a += g.open.length, d = t.src.slice(a, s), o)
        return !0;
      for (d.trim().slice(-g.close.length) === g.close && (d = d.trim().slice(0, -g.close.length), l = !0), i = r; !l && (i++, !(i >= n || (a = t.bMarks[i] + t.tShift[i], s = t.eMarks[i], a < s && t.tShift[i] < t.blkIndent))); )
        t.src.slice(a, s).trim().slice(-g.close.length) === g.close && (u = t.src.slice(0, s).lastIndexOf(g.close), c = t.src.slice(a, u), l = !0);
      t.line = i + 1;
      const f = t.push("math_block", "math", 0);
      return f.block = !0, f.content = (d && d.trim() ? d + `
` : "") + t.getLines(r + 1, i, t.tShift[r], !0) + (c && c.trim() ? c : ""), f.map = [r, t.line], f.markup = g.open, !0;
    }
  return !1;
}, ft = (e, { katexRef: t, inlineDelimiters: r, blockDelimiters: n }) => {
  const o = (d, c, i, u, l) => {
    const a = d[c], s = {
      attrs: ee(a, [["class", `${h}-katex-inline`]])
    };
    if (t.value) {
      const g = t.value.renderToString(
        a.content,
        M.katexConfig({
          throwOnError: !1
        })
      );
      return `<span ${l.renderAttrs(s)} data-processed>${g}</span>`;
    } else
      return `<span ${l.renderAttrs(s)}>${a.content}</span>`;
  }, m = (d, c, i, u, l) => {
    const a = d[c], s = {
      attrs: ee(a, [["class", `${h}-katex-block`]])
    };
    if (t.value) {
      const g = t.value.renderToString(
        a.content,
        M.katexConfig({
          throwOnError: !1,
          displayMode: !0
        })
      );
      return `<p ${l.renderAttrs(s)} data-processed>${g}</p>`;
    } else
      return `<p ${l.renderAttrs(s)}>${a.content}</p>`;
  };
  e.inline.ruler.before(
    "escape",
    "math_inline",
    ut({
      delimiters: r || be.inline
    })
  ), e.block.ruler.after(
    "blockquote",
    "math_block",
    mt({
      delimiters: n || be.block
    }),
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  ), e.renderer.rules.math_inline = o, e.renderer.rules.math_block = m;
}, ht = (e, t) => {
  const r = e.renderer.rules.fence.bind(e.renderer.rules);
  e.renderer.rules.fence = (n, o, m, d, c) => {
    const i = n[o], u = i.content.trim();
    if (i.info === "mermaid") {
      if (i.attrSet("class", `${h}-mermaid`), i.attrSet("data-mermaid-theme", t.themeRef.value), i.map && i.level === 0) {
        const a = i.map[1] - 1, g = !!d.srcLines[a]?.trim()?.startsWith("```");
        i.attrSet("data-closed", `${g}`), i.attrSet("data-line", String(i.map[0]));
      }
      const l = Y.get(u);
      return l ? (i.attrSet("data-processed", ""), i.attrSet("data-content", u), `<p ${c.renderAttrs(i)}>${l}</p>`) : `<div ${c.renderAttrs(i)}>${e.utils.escapeHtml(u)}</div>`;
    }
    return r(n, o, m, d, c);
  };
}, $e = (e, t, r) => {
  const n = e.attrIndex(t), o = [t, r];
  n < 0 ? e.attrPush(o) : (e.attrs = e.attrs || [], e.attrs[n] = o);
}, pt = (e) => e.type === "inline", gt = (e) => e.type === "paragraph_open", vt = (e) => e.type === "list_item_open", yt = (e) => e.content.indexOf("[ ] ") === 0 || e.content.indexOf("[x] ") === 0 || e.content.indexOf("[X] ") === 0, bt = (e, t) => pt(e[t]) && gt(e[t - 1]) && vt(e[t - 2]) && yt(e[t]), $t = (e, t) => {
  const r = e[t].level - 1;
  for (let n = t - 1; n >= 0; n--)
    if (e[n].level === r)
      return n;
  return -1;
}, wt = (e) => {
  const t = new e("html_inline", "", 0);
  return t.content = "<label>", t;
}, Ct = (e) => {
  const t = new e("html_inline", "", 0);
  return t.content = "</label>", t;
}, kt = (e, t, r) => {
  const n = new r("html_inline", "", 0);
  return n.content = '<label class="task-list-item-label" for="' + t + '">' + e + "</label>", n.attrs = [["for", t]], n;
}, Et = (e, t, r) => {
  const n = new t("html_inline", "", 0), o = r.enabled ? " " : ' disabled="" ';
  return e.content.indexOf("[ ] ") === 0 ? n.content = '<input class="task-list-item-checkbox"' + o + 'type="checkbox">' : (e.content.indexOf("[x] ") === 0 || e.content.indexOf("[X] ") === 0) && (n.content = '<input class="task-list-item-checkbox" checked=""' + o + 'type="checkbox">'), n;
}, Tt = (e, t, r) => {
  if (e.children = e.children || [], e.children.unshift(Et(e, t, r)), e.children[1].content = e.children[1].content.slice(3), e.content = e.content.slice(3), r.label)
    if (r.labelAfter) {
      e.children.pop();
      const n = "task-item-" + Math.ceil(Math.random() * (1e4 * 1e3) - 1e3);
      e.children[0].content = e.children[0].content.slice(0, -1) + ' id="' + n + '">', e.children.push(kt(e.content, n, t));
    } else
      e.children.unshift(wt(t)), e.children.push(Ct(t));
}, It = (e, t = {}) => {
  e.core.ruler.after("inline", "github-task-lists", (r) => {
    const n = r.tokens;
    for (let o = 2; o < n.length; o++)
      bt(n, o) && (Tt(n[o], r.Token, t), $e(
        n[o - 2],
        "class",
        "task-list-item" + (t.enabled ? " enabled" : " ")
      ), $e(n[$t(n, o - 2)], "class", "contains-task-list"));
  });
}, St = (e) => {
  e.core.ruler.push("init-line-number", (t) => (t.tokens.forEach((r) => {
    r.map && (r.attrs || (r.attrs = []), r.attrs.push(["data-line", r.map[0].toString()]));
  }), !0));
}, xt = (e, t) => {
  const { editorConfig: r, markdownItConfig: n, markdownItPlugins: o, editorExtensions: m } = M, d = $("editorId"), c = $("language"), i = $(
    "usedLanguageText"
  ), u = $("showCodeRowNumber"), l = $("theme"), a = $("customIcon"), s = $("rootRef"), g = $("setting"), f = U([]), p = at(e), b = rt(e), { reRenderRef: S, replaceMermaid: v } = lt(e), { reRenderEcharts: C, replaceEcharts: x } = ot(e), w = Ke({
    html: !0,
    breaks: !0,
    linkify: !0
  });
  n(w, {
    editorId: d
  });
  const H = [
    {
      type: "image",
      plugin: Ze,
      options: { figcaption: !0, classes: "md-zoom" }
    },
    {
      type: "admonition",
      plugin: it,
      options: {}
    },
    {
      type: "taskList",
      plugin: It,
      options: {}
    },
    {
      type: "heading",
      plugin: dt,
      options: { mdHeadingId: e.mdHeadingId, headsRef: f }
    },
    {
      type: "code",
      plugin: st,
      options: {
        editorId: d,
        usedLanguageTextRef: i,
        // showCodeRowNumber,
        codeFoldable: e.codeFoldable,
        autoFoldThreshold: e.autoFoldThreshold,
        customIconRef: a
      }
    },
    {
      type: "sub",
      plugin: Je,
      options: {}
    },
    {
      type: "sup",
      plugin: Xe,
      options: {}
    }
  ];
  e.noKatex || H.push({
    type: "katex",
    plugin: ft,
    options: { katexRef: b }
  }), e.noMermaid || H.push({
    type: "mermaid",
    plugin: ht,
    options: { themeRef: l }
  }), e.noEcharts || H.push({
    type: "echarts",
    plugin: ct,
    options: { themeRef: l }
  }), o(H, {
    editorId: d
  }).forEach((E) => {
    w.use(E.plugin, E.options);
  });
  const I = w.options.highlight;
  w.set({
    highlight: (E, F, J) => {
      if (I) {
        const W = I(E, F, J);
        if (W)
          return W;
      }
      let j;
      !e.noHighlight && p.value ? p.value.getLanguage(F) ? j = p.value.highlight(E, {
        language: F,
        ignoreIllegals: !0
      }).value : j = p.value.highlightAuto(E).value : j = w.utils.escapeHtml(E);
      const oe = u ? Ye(
        j.replace(/^\n+|\n+$/g, ""),
        E.replace(/^\n+|\n+$/g, "")
      ) : `<span class="${h}-code-block">${j.replace(/^\n+|\n+$/g, "")}</span>`;
      return `<pre><code class="language-${F}" language=${F}>${oe}</code></pre>`;
    }
  }), St(w);
  const _ = U(`_article-key_${ie()}`), N = U(
    e.sanitize(
      w.render(e.modelValue, {
        srcLines: e.modelValue.split(`
`)
      })
    )
  );
  let B = () => {
  }, D = () => {
  };
  const q = () => {
    const E = s.value?.querySelectorAll(
      `#${d} p.${h}-mermaid:not([data-closed=false])`
    );
    D(), D = ze(E, {
      customIcon: a.value
    }), m.mermaid?.enableZoom && (B(), B = We(E, {
      customIcon: a.value
    }));
  }, V = () => {
    y.emit(d, X, N.value), e.onHtmlChanged(N.value), e.onGetCatalog(f.value), y.emit(d, ae, f.value), G(() => {
      v().then(q), x();
    });
  }, z = () => {
    f.value = [], N.value = e.sanitize(
      w.render(e.modelValue, {
        srcLines: e.modelValue.split(`
`)
      })
    );
  }, K = A(() => (e.noKatex || !!b.value) && (e.noHighlight || !!p.value));
  let Z = -1;
  return k([Re(e, "modelValue"), K, S, c], () => {
    Z = window.setTimeout(
      () => {
        z();
      },
      t ? 0 : r.renderDelay
    );
  }), k(
    () => g.value.preview,
    () => {
      g.value.preview && G(() => {
        v().then(q), x(), y.emit(d, ae, f.value);
      });
    }
  ), k([N, C], () => {
    V();
  }), R(V), R(() => {
    y.on(d, {
      name: De,
      callback() {
        y.emit(d, ae, f.value);
      }
    }), y.on(d, {
      name: de,
      callback: () => {
        _.value = `_article-key_${ie()}`, z();
      }
    });
  }), ne(() => {
    B(), D(), clearTimeout(Z);
  }), { html: N, key: _ };
}, Ft = (e, t) => {
  const r = $("editorId"), n = $("setting"), { noImgZoomIn: o } = e, m = Le(() => {
    const d = document.querySelectorAll(
      `#${r}-preview img:not(.not-zoom):not(.medium-zoom-image)`
    );
    d.length !== 0 && et(d, {
      background: "#00000073"
    });
  });
  R(async () => {
    !o && n.value.preview && await m();
  }), k([t, () => n.value.preview], async () => {
    !o && n.value.preview && await m();
  });
}, we = {
  checked: {
    regexp: /- \[x\]/,
    value: "- [ ]"
  },
  unChecked: {
    regexp: /- \[\s\]/,
    value: "- [x]"
  }
}, At = (e, t) => {
  const r = $("editorId"), n = $("rootRef");
  let o = () => {
  };
  const m = () => {
    if (!n.value)
      return !1;
    const d = n.value.querySelectorAll(".task-list-item.enabled"), c = (i) => {
      i.preventDefault();
      const u = i.target.checked ? "unChecked" : "checked", l = i.target.parentElement?.dataset.line;
      if (!l)
        return;
      const a = Number(l), s = e.modelValue.split(`
`), g = s[Number(a)].replace(
        we[u].regexp,
        we[u].value
      );
      e.previewOnly ? (s[Number(a)] = g, e.onChange(s.join(`
`))) : y.emit(r, Ve, a + 1, g);
    };
    d.forEach((i) => {
      i.addEventListener("click", c);
    }), o = () => {
      d.forEach((i) => {
        i.removeEventListener("click", c);
      });
    };
  };
  ne(() => {
    o();
  }), k(
    [t],
    () => {
      o(), G(m);
    },
    {
      immediate: !0
    }
  );
}, Rt = (e, t, r) => {
  const n = $("setting"), o = () => {
    G(() => {
      e.onRemount?.();
    });
  }, m = (d) => {
    d && o();
  };
  k([t, r], o), k(() => n.value.preview, m), k(() => n.value.htmlPreview, m), R(o);
}, Se = {
  modelValue: {
    type: String,
    default: ""
  },
  onChange: {
    type: Function,
    default: () => {
    }
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  mdHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: !1
  },
  sanitize: {
    type: Function,
    default: (e) => e
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: !1
  },
  formatCopiedText: {
    type: Function,
    default: (e) => e
  },
  noHighlight: {
    type: Boolean,
    default: !1
  },
  previewOnly: {
    type: Boolean,
    default: !1
  },
  noImgZoomIn: {
    type: Boolean
  },
  sanitizeMermaid: {
    type: Function
  },
  codeFoldable: {
    type: Boolean
  },
  autoFoldThreshold: {
    type: Number
  },
  onRemount: {
    type: Function
  },
  noEcharts: {
    type: Boolean
  }
}, nn = {
  ...Se,
  updateModelValue: {
    type: Function,
    default: () => {
    }
  },
  placeholder: {
    type: String,
    default: ""
  },
  scrollAuto: {
    type: Boolean
  },
  autofocus: {
    type: Boolean
  },
  readonly: {
    type: Boolean
  },
  maxlength: {
    type: Number
  },
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: () => {
    }
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: () => {
    }
  },
  completions: {
    type: Array
  },
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function,
    default: () => {
    }
  },
  inputBoxWidth: {
    type: String
  },
  oninputBoxWidthChange: {
    type: Function
  },
  transformImgUrl: {
    type: Function,
    default: (e) => e
  },
  catalogLayout: {
    type: String
  },
  catalogMaxDepth: {
    type: Number
  }
}, Ce = (e) => {
  const r = new DOMParser().parseFromString(e, "text/html");
  return Array.from(r.body.childNodes);
}, Ht = (e, t) => e.nodeType !== t.nodeType ? !1 : e.nodeType === Node.TEXT_NODE || e.nodeType === Node.COMMENT_NODE ? e.textContent === t.textContent : e.nodeType === Node.ELEMENT_NODE ? e.outerHTML === t.outerHTML : e.isEqualNode ? e.isEqualNode(t) : !1, ke = /* @__PURE__ */ ce({
  name: "UpdateOnDemand",
  props: {
    html: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    const t = $("editorId"), r = $("previewTheme"), n = $("showCodeRowNumber"), o = U(), m = e.html, d = (c, i) => {
      if (!o.value) return;
      const u = o.value, l = Array.from(u.childNodes), a = Math.min(c.length, i.length);
      let s = -1;
      for (let f = 0; f < a; f++)
        if (!Ht(c[f], i[f])) {
          s = f;
          break;
        }
      if (s === -1)
        if (i.length > c.length)
          s = c.length;
        else if (c.length > i.length)
          s = i.length;
        else
          return;
      const g = Math.min(s, l.length);
      for (let f = l.length - 1; f >= g; f--)
        l[f].remove();
      for (let f = s; f < c.length; f++)
        u.appendChild(c[f].cloneNode(!0));
    };
    return k(() => e.html, (c, i) => {
      const u = Ce(c), l = Ce(i || "");
      d(u, l);
    }), () => O("div", {
      id: `${t}-preview`,
      class: [`${h}-preview`, `${r?.value}-theme`, n && `${h}-scrn`],
      innerHTML: m,
      ref: o
    }, null);
  }
}), Mt = /* @__PURE__ */ ce({
  name: "ContentPreview",
  props: Se,
  setup(e) {
    const t = $("editorId"), r = $("setting"), {
      html: n,
      key: o
    } = xt(e, e.previewOnly);
    return nt(e, n, o), Ft(e, n), At(e, n), Rt(e, n, o), () => O(He, null, [r.value.preview && (e.previewOnly ? O(ke, {
      key: o.value,
      html: n.value
    }, null) : O("div", {
      id: `${t}-preview-wrapper`,
      class: `${h}-preview-wrapper`,
      key: "content-preview-wrapper"
    }, [O(ke, {
      key: o.value,
      html: n.value
    }, null)])), r.value.htmlPreview && O("div", {
      id: `${t}-html-wrapper`,
      class: `${h}-preview-wrapper`,
      key: "html-preview-wrapper"
    }, [O("div", {
      class: `${h}-html`
    }, [n.value])])]);
  }
}), Pt = ({ text: e }) => e, xe = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * input回调事件
   */
  onChange: {
    type: Function,
    default: void 0
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function,
    default: void 0
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function,
    default: void 0
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   * @deprecated 5.x版本开始使用 id 替换
   */
  editorId: {
    type: String,
    default: void 0
  },
  /**
   * 5.x版本开始 editorId 的替换
   *
   * @default 'md-editor-v3'
   */
  id: {
    type: String,
    default: void 0
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default true
   */
  showCodeRowNumber: {
    type: Boolean,
    default: !0
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: Pt
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (e) => e
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: !1
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: !1
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (e) => e
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: !0
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  noHighlight: {
    type: Boolean,
    default: !1
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: !1
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  },
  sanitizeMermaid: {
    type: Function,
    default: (e) => Promise.resolve(e)
  },
  /**
   * 是否开启折叠代码功能
   * 不开启会使用div标签替代details标签
   *
   * @default true
   */
  codeFoldable: {
    type: Boolean,
    default: !0
  },
  /**
   * 触发自动折叠代码的行数阈值
   *
   * @default 30
   */
  autoFoldThreshold: {
    type: Number,
    default: 30
  },
  /**
   * 内容重新挂载事件
   *
   * 相比起onHtmlChanged，onRemount会在重新挂载后触发
   */
  onRemount: {
    type: Function,
    default: void 0
  },
  /**
   * 不使用 echarts
   */
  noEcharts: {
    type: Boolean,
    default: !1
  }
}, on = {
  ...xe,
  /**
   * input回调事件
   */
  onSave: {
    type: Function,
    default: void 0
  },
  /**
   * 上传图片事件
   */
  onUploadImg: {
    type: Function,
    default: void 0
  },
  /**
   * 是否页面内全屏
   *
   * @default false
   */
  pageFullscreen: {
    type: Boolean,
    default: !1
  },
  /**
   * 是否展开预览
   *
   * @default true
   */
  preview: {
    type: Boolean,
    default: !0
  },
  /**
   * 是否展开html预览
   *
   * @default false
   */
  htmlPreview: {
    type: Boolean,
    default: !1
  },
  /**
   * 仅预览模式，不显示toolbar和编辑框
   *
   * @4.0.0开始移除该设置，使用组件MdPreview替换
   *
   * @default false
   */
  // previewOnly: {
  //   type: Boolean as PropType<boolean>,
  //   default: false
  // },
  /**
   * 工具栏选择显示
   *
   * @default allToolbar
   */
  toolbars: {
    type: Array,
    default: Oe
  },
  /**
   * 浮动工具栏
   *
   * @version 6.0.0
   * @default []
   */
  floatingToolbars: {
    type: Array,
    default: []
  },
  /**
   * 工具栏选择不显示
   *
   * @default []
   */
  toolbarsExclude: {
    type: Array,
    default: []
  },
  /**
   * 格式化md
   *
   * @default true
   */
  noPrettier: {
    type: Boolean,
    default: !1
  },
  /**
   * 一个tab等于空格数
   *
   * @default 2
   */
  tabWidth: {
    type: Number,
    default: 2
  },
  /**
   * 表格预设格子数
   *
   * 也可以是[6, 4, 10, 8]
   *
   * @default [6, 4]
   */
  tableShape: {
    type: Array,
    default: [6, 4]
  },
  /**
   * 空提示
   *
   * @default ''
   */
  placeholder: {
    type: String,
    default: ""
  },
  /**
   * 自定义的工具栏列表
   */
  defToolbars: {
    type: [String, Object],
    default: void 0
  },
  /**
   * 内部错误捕获
   */
  onError: {
    type: Function,
    default: void 0
  },
  /**
   * 页脚列表显示顺序
   */
  footers: {
    type: Array,
    default: _e
  },
  /**
   * 是否默认激活输入框和预览框同步滚动
   *
   * @default true
   */
  scrollAuto: {
    type: Boolean,
    default: !0
  },
  /**
   * 自定义的也叫工具组件列表
   */
  defFooters: {
    type: [String, Object],
    default: void 0
  },
  /**
   * 是否禁用上传图片
   *
   * @default false
   */
  noUploadImg: {
    type: Boolean,
    default: !1
  },
  /**
   * 文本区域自动获得焦点
   *
   * @default false
   */
  autoFocus: {
    type: Boolean,
    default: !1
  },
  /**
   * 禁用文本区域
   *
   * @default false
   */
  disabled: {
    type: Boolean,
    default: !1
  },
  /**
   * 文本区域为只读
   *
   * @default false
   */
  readOnly: {
    type: Boolean,
    default: !1
  },
  /**
   * 文本区域允许的最大字符数
   */
  maxLength: {
    type: Number,
    default: void 0
  },
  /**
   * 是否启用自动识别粘贴代码类别
   * 目前支持 vscode 复制的代码识别
   *
   * @default false
   */
  autoDetectCode: {
    type: Boolean,
    default: !1
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: void 0
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: void 0
  },
  /**
   * @codemirror/autocomplete匹配关键词的方法列表
   *
   * 它会被像下面这样嵌入编辑器
   *
   * import { autocompletion } from '@codemirror/autocomplete';
   * autocompletion({
   *   override: [...completions]
   * })
   */
  completions: {
    type: Array,
    default: void 0
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean,
    default: !1
  },
  /**
   * 字符输入事件
   */
  onInput: {
    type: Function,
    default: void 0
  },
  onDrop: {
    type: Function,
    default: void 0
  },
  /**
   * 输入框的默认宽度
   *
   * @example '100px'/'50%'
   * @default '50%
   */
  inputBoxWidth: {
    type: String,
    default: "50%"
  },
  /**
   * 输入框宽度变化事件
   */
  oninputBoxWidthChange: {
    type: Function,
    default: void 0
  },
  /**
   * 替换粘贴的图片链接
   *
   * @param t 图片链接
   * @returns
   */
  transformImgUrl: {
    type: Function,
    default: (e) => e
  },
  /**
   * 内置的目录显示的状态
   *
   * 'fixed': 悬浮在内容上方
   * 'flat': 展示在右侧
   *
   * \>=5.3.0
   *
   * @default 'fixed'
   */
  catalogLayout: {
    type: String,
    default: "fixed"
  },
  /**
   * 控制最大显示的目录层级
   */
  catalogMaxDepth: {
    type: Number,
    default: void 0
  }
}, Fe = [
  "onHtmlChanged",
  "onGetCatalog",
  "onChange",
  "onRemount",
  "update:modelValue"
], an = [
  ...Fe,
  "onSave",
  "onUploadImg",
  "onError",
  "onBlur",
  "onFocus",
  "onInput",
  "onDrop",
  "oninputBoxWidthChange"
], Lt = (e, t, r) => {
  const { editorId: n } = r, o = {
    rerender() {
      y.emit(n, de);
    }
  };
  t.expose(o);
}, re = /* @__PURE__ */ ce({
  name: "MdPreview",
  props: xe,
  emits: Fe,
  setup(e, t) {
    const {
      noKatex: r,
      noMermaid: n,
      noHighlight: o
    } = e, m = U(), d = tt(e);
    return Ie(e, {
      rootRef: m,
      editorId: d
    }), Lt(e, t, {
      editorId: d
    }), ne(() => {
      y.clear(d);
    }), () => O("div", {
      id: d,
      class: [h, e.class, e.theme === "dark" && `${h}-dark`, `${h}-previewOnly`],
      style: e.style,
      ref: m
    }, [O(Mt, {
      modelValue: e.modelValue,
      onChange: (c) => {
        e.onChange?.(c), t.emit("onChange", c), t.emit("update:modelValue", c);
      },
      onHtmlChanged: (c) => {
        e.onHtmlChanged?.(c), t.emit("onHtmlChanged", c);
      },
      onGetCatalog: (c) => {
        e.onGetCatalog?.(c), t.emit("onGetCatalog", c);
      },
      mdHeadingId: e.mdHeadingId,
      noMermaid: n,
      sanitize: e.sanitize,
      noKatex: r,
      formatCopiedText: e.formatCopiedText,
      noHighlight: o,
      noImgZoomIn: e.noImgZoomIn,
      previewOnly: !0,
      sanitizeMermaid: e.sanitizeMermaid,
      codeFoldable: e.codeFoldable,
      autoFoldThreshold: e.autoFoldThreshold,
      onRemount: () => {
        e.onRemount?.(), t.emit("onRemount");
      },
      noEcharts: e.noEcharts
    }, null)]);
  }
});
re.install = (e) => (e.component(re.name, re), e);
export {
  P as C,
  re as M,
  Mt as a,
  on as b,
  nn as c,
  Qt as d,
  an as e,
  en as f,
  Zt as g,
  Xt as h,
  Yt as i,
  tn as j,
  Jt as k,
  tt as u
};
