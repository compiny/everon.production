import { defineComponent as z, inject as q, ref as _, watch as J, onMounted as K, createVNode as M, reactive as X, shallowRef as G, provide as V, computed as Y, onBeforeUnmount as Z, Fragment as ee } from "vue";
import { p as w } from "./config.mjs";
import { b as B, j, G as U, k as te, S as le } from "./event-bus.mjs";
import { a as oe } from "./index5.mjs";
import { createSmoothScroll as ne, debounce as ie } from "@vavt/util";
const se = `.${w}-preview > [data-line]`, F = (e, t) => +getComputedStyle(e).getPropertyValue(t).replace("px", ""), ve = (e, t) => {
  const E = ie(() => {
    e.removeEventListener("scroll", s), e.addEventListener("scroll", s), t.removeEventListener("scroll", s), t.addEventListener("scroll", s);
  }, 50), s = (n) => {
    const k = e.clientHeight, L = t.clientHeight, v = e.scrollHeight, r = t.scrollHeight, g = (v - k) / (r - L);
    n.target === e ? (t.removeEventListener("scroll", s), t.scrollTo({
      top: e.scrollTop / g
      // behavior: 'smooth'
    }), E()) : (e.removeEventListener("scroll", s), e.scrollTo({
      top: t.scrollTop * g
      // behavior: 'smooth'
    }), E());
  };
  return [
    () => {
      E().finally(() => {
        e.dispatchEvent(new Event("scroll"));
      });
    },
    () => {
      e.removeEventListener("scroll", s), t.removeEventListener("scroll", s);
    }
  ];
}, ge = (e, t, E) => {
  const { view: s } = E, n = ne(), k = (a) => s.lineBlockAt(s.state.doc.line(a + 1).from).top, L = (a) => s.lineBlockAt(s.state.doc.line(a + 1).from).bottom;
  let v = [], r = [], g = [];
  const y = () => {
    v = [], r = Array.from(
      t.querySelectorAll(se)
    ), g = r.map((f) => Number(f.dataset.line));
    const a = [...g], { lines: h } = s.state.doc;
    let l = a.shift() || 0, o = a.shift() || h;
    for (let f = 0; f < h; f++)
      f === o && (l = f, o = a.shift() || h), v.push({
        start: l,
        end: o - 1
      });
  }, x = (a, h) => {
    let l = 1;
    for (let o = r.length - 1; o - 1 >= 0; o--) {
      const f = r[o], c = r[o - 1];
      if (f.offsetTop + f.offsetHeight > h && c.offsetTop < h) {
        l = Number(c.dataset.line);
        break;
      }
    }
    for (let o = v.length - 1; o >= 0; o--) {
      const f = L(v[o].end), c = k(v[o].start);
      if (f > a && c <= a) {
        l = l < v[o].start ? l : v[o].start;
        break;
      }
    }
    return l;
  };
  let S = 0, O = 0;
  const $ = () => {
    if (O !== 0)
      return !1;
    S++;
    const { scrollDOM: a, contentHeight: h } = s;
    let l = F(t, "padding-top");
    const o = s.lineBlockAtHeight(a.scrollTop), { number: f } = s.state.doc.lineAt(o.from), c = v[f - 1];
    if (!c)
      return !1;
    let m = 1;
    const u = t.querySelector(`[data-line="${c.start}"]`) || t.firstElementChild?.firstElementChild, i = t.querySelector(`[data-line="${c.end + 1}"]`) || t.lastElementChild?.lastElementChild, T = a.scrollHeight - a.clientHeight, C = t.scrollHeight - t.clientHeight;
    let d = k(c.start), I = L(c.end), b = u.offsetTop, A = i.offsetTop - b;
    d === 0 && (b = 0, u === i ? (l = 0, I = h - a.offsetHeight, A = C) : A = i.offsetTop), m = (a.scrollTop - d) / (I - d);
    const N = i == t.lastElementChild?.lastElementChild ? i.offsetTop + i.clientHeight : i.offsetTop;
    if (I >= T || N > C) {
      const H = x(T, C);
      d = k(H), m = (a.scrollTop - d) / (T - d);
      const P = t.querySelector(`[data-line="${H}"]`);
      d > 0 && P && (b = P.offsetTop), A = C - b + F(t, "padding-top");
    }
    const p = b - l + A * m;
    n(t, p, () => {
      S--;
    });
  }, D = () => {
    if (S !== 0)
      return;
    O++;
    const { scrollDOM: a } = s, h = t.scrollTop, l = t.scrollHeight, o = a.scrollHeight - a.clientHeight, f = t.scrollHeight - t.clientHeight;
    let c = t.firstElementChild?.firstElementChild, m = t.firstElementChild?.lastElementChild;
    if (g.length > 0) {
      let N = Math.ceil(
        g[g.length - 1] * (h / l)
      ), p = g.findLastIndex((H) => H <= N);
      p = p === -1 ? 0 : p, N = g[p];
      for (let H = p; H >= 0 && H < g.length; )
        if (r[H].offsetTop > h) {
          if (H - 1 >= 0) {
            H--;
            continue;
          }
          N = -1, p = H;
          break;
        } else {
          if (H + 1 < g.length && r[H + 1].offsetTop < h) {
            H++;
            continue;
          }
          N = g[H], p = H;
          break;
        }
      switch (p) {
        case -1: {
          c = t.firstElementChild?.firstElementChild, m = r[p];
          break;
        }
        case g.length - 1: {
          c = r[p], m = t.firstElementChild?.lastElementChild;
          break;
        }
        default:
          c = r[p], m = r[p + 1 === r.length ? p : p + 1];
      }
    }
    let u = c === t.firstElementChild?.firstElementChild ? 0 : c.offsetTop - F(c, "margin-top"), i = m.offsetTop, T = 0;
    const { start: C, end: d } = v[Number(c.dataset.line || 0)];
    let I = k(C);
    const b = k(
      d + 1 === s.state.doc.lines ? d : d + 1
    );
    let A = 0;
    if (b > o || m.offsetTop + m.offsetHeight > f) {
      const N = x(o, f), p = t.querySelector(`[data-line="${N}"]`);
      u = p ? p.offsetTop - F(p, "margin-top") : u, I = k(N), T = (h - u) / (f - u), A = o - I;
    } else c === t.firstElementChild?.firstElementChild ? (c === m && (i = m.offsetTop + m.offsetHeight + +getComputedStyle(m).marginBottom.replace("px", "")), A = b, T = Math.max(h / i, 0)) : (T = Math.max(
      (h - u) / (i - u),
      0
    ), A = b - I);
    n(e, I + A * T, () => {
      O--;
    });
  }, R = (a) => {
    const { scrollDOM: h, contentHeight: l } = s, o = h.clientHeight;
    if (l <= o || t.firstElementChild.clientHeight <= t.clientHeight || s.state.doc.lines <= v[v.length - 1]?.end)
      return !1;
    a.target === e ? $() : D();
  };
  return [
    () => {
      y(), e.addEventListener("scroll", R), t.addEventListener("scroll", R), e.dispatchEvent(new Event("scroll"));
    },
    () => {
      e.removeEventListener("scroll", R), t.removeEventListener("scroll", R);
    }
  ];
}, re = {
  tocItem: {
    type: Object,
    default: () => ({})
  },
  mdHeadingId: {
    type: Function,
    default: () => {
    }
  },
  onActive: {
    type: Function,
    default: () => {
    }
  },
  onClick: {
    type: Function,
    default: () => {
    }
  },
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  }
}, Q = /* @__PURE__ */ z({
  props: re,
  setup(e) {
    const t = q("scrollElementRef"), E = q("roorNodeRef"), s = _();
    return J(() => e.tocItem.active, (n) => {
      n && e.onActive(e.tocItem, s.value);
    }), K(() => {
      e.tocItem.active && e.onActive(e.tocItem, s.value);
    }), () => {
      const {
        tocItem: n,
        mdHeadingId: k,
        onClick: L,
        scrollElementOffsetTop: v
      } = e;
      return M("div", {
        ref: s,
        class: [`${w}-catalog-link`, n.active && `${w}-catalog-active`],
        onClick: (r) => {
          if (r.stopPropagation(), L(r, n), r.defaultPrevented)
            return;
          const g = k({
            text: n.text,
            level: n.level,
            index: n.index,
            currentToken: n.currentToken,
            nextToken: n.nextToken
          }), y = E.value.getElementById(g), x = t.value;
          if (y && x) {
            let S = y.offsetParent, O = y.offsetTop;
            if (x.contains(S))
              for (; S && x != S; )
                O += S?.offsetTop, S = S?.offsetParent;
            const $ = y.previousElementSibling;
            let D = 0;
            $ || (D = F(y, "margin-top")), x?.scrollTo({
              top: O - v - D,
              behavior: "smooth"
            });
          }
        }
      }, [M("span", {
        title: n.text
      }, [n.text]), n.children && n.children.length > 0 && M("div", {
        class: `${w}-catalog-wrapper`
      }, [n.children.map((r) => M(Q, {
        mdHeadingId: k,
        key: `${n.text}-link-${r.level}-${r.text}`,
        tocItem: r,
        onActive: e.onActive,
        onClick: L,
        scrollElementOffsetTop: v
      }, null))])]);
    };
  }
}), ce = {
  /**
   * 编辑器的Id，务必与需要绑定的编辑器Id相同
   */
  editorId: {
    type: String,
    default: void 0
  },
  class: {
    type: String,
    default: ""
  },
  mdHeadingId: {
    type: Function,
    default: ({
      text: e
    }) => e
  },
  /**
   * 指定滚动的容器，选择器需带上对应的符号，默认预览框
   * 元素必须定位！！！！！！
   *
   * 默认：#md-editor-preview-wrapper
   */
  scrollElement: {
    type: [String, Object],
    default: void 0
  },
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 高亮标题相对滚动容器顶部偏移量，即距离该值时，高亮当前目录菜单项
   *
   * 默认：20px
   */
  offsetTop: {
    type: Number,
    default: 20
  },
  /**
   * 滚动区域的固定顶部高度
   *
   * 默认：0
   */
  scrollElementOffsetTop: {
    type: Number,
    default: 0
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onActive: {
    type: Function,
    default: void 0
  },
  /**
   * 滚动容器是否在web component中，默认不在
   *
   * 在其中的话通过document查询不到
   */
  isScrollElementInShadow: {
    type: Boolean,
    default: !1
  },
  /**
   * 设置与哪个区域同步，默认与内容区域同步
   *
   * >= v5.3.0
   */
  syncWith: {
    type: String,
    default: "preview"
  },
  /**
   * 控制最大显示的目录层级
   */
  catalogMaxDepth: {
    type: Number,
    default: void 0
  }
}, W = /* @__PURE__ */ z({
  name: "MdCatalog",
  props: ce,
  emits: ["onClick", "onActive"],
  setup(e, t) {
    const E = e.editorId, s = `#${E}-preview-wrapper`, n = X({
      list: [],
      show: !1,
      scrollElement: e.scrollElement || s
    }), k = G(), L = _(), v = _(), r = _(), g = _(), y = G(), x = _({});
    V("scrollElementRef", v), V("roorNodeRef", g);
    const S = Y(() => {
      const l = [];
      return n.list.forEach((o, f) => {
        if (e.catalogMaxDepth && o.level > e.catalogMaxDepth)
          return;
        const {
          text: c,
          level: m,
          line: u
        } = o, i = {
          level: m,
          text: c,
          line: u,
          index: f + 1,
          active: k.value === o
        };
        if (l.length === 0)
          l.push(i);
        else {
          let T = l[l.length - 1];
          if (i.level > T.level)
            for (let C = T.level + 1; C <= 6; C++) {
              const {
                children: d
              } = T;
              if (!d) {
                T.children = [i];
                break;
              }
              if (T = d[d.length - 1], i.level <= T.level) {
                d.push(i);
                break;
              }
            }
          else
            l.push(i);
        }
      }), l;
    }), O = () => {
      if (n.scrollElement instanceof HTMLElement)
        return n.scrollElement;
      let l = document;
      return (n.scrollElement === s || e.isScrollElementInShadow) && (l = L.value?.getRootNode()), l.querySelector(n.scrollElement);
    }, $ = (l) => {
      if (l.length === 0)
        return k.value = void 0, n.list = [], !1;
      const {
        activeHead: o,
        activeIndex: f
      } = l.reduce((u, i, T) => {
        let C = 0;
        if (e.syncWith === "preview") {
          const d = g.value?.getElementById(e.mdHeadingId({
            text: i.text,
            level: i.level,
            index: T + 1,
            currentToken: i.currentToken,
            nextToken: i.nextToken
          }));
          d instanceof HTMLElement && (C = oe(d, v.value));
        } else {
          const d = y.value;
          if (d) {
            const I = d.lineBlockAt(d.state.doc.line(i.line + 1).from).top, b = d.scrollDOM.scrollTop;
            C = I - b;
          }
        }
        return C < e.offsetTop && C > u.minTop ? {
          activeHead: i,
          activeIndex: T,
          minTop: C
        } : u;
      }, {
        activeHead: l[0],
        activeIndex: 0,
        minTop: Number.MIN_SAFE_INTEGER
      });
      let c = o;
      const {
        catalogMaxDepth: m
      } = e;
      if (m && c.level > m) {
        for (let u = f; u >= 0; u--) {
          const i = l[u];
          if (i.level <= m) {
            c = i;
            break;
          }
        }
        if (c.level > m) {
          const u = l.find((i) => i.level <= m);
          u && (c = u);
        }
      }
      k.value = c, n.list = l;
    }, D = (l, o) => {
      x.value.top = o.offsetTop + F(o, "padding-top") + "px", e.onActive?.(l, o), t.emit("onActive", l, o);
    }, R = () => {
      $(n.list);
    }, a = (l) => {
      if (r.value?.removeEventListener("scroll", R), e.syncWith === "editor")
        r.value = y.value?.scrollDOM;
      else {
        const o = O();
        v.value = o, r.value = o === document.documentElement ? document : o;
      }
      $(l), r.value?.addEventListener("scroll", R);
    }, h = (l) => {
      y.value = l;
    };
    return J([() => e.syncWith, y, () => e.catalogMaxDepth], () => {
      a(n.list);
    }), K(() => {
      g.value = L.value.getRootNode(), B.on(E, {
        name: j,
        callback: a
      }), B.on(E, {
        name: U,
        callback: h
      }), B.emit(E, te), B.emit(E, le);
    }), Z(() => {
      B.remove(E, j, a), B.remove(E, U, h), r.value?.removeEventListener("scroll", R);
    }), () => M("div", {
      class: [`${w}-catalog`, e.theme === "dark" && `${w}-catalog-dark`, e.class || ""],
      ref: L
    }, [S.value.length > 0 && M(ee, null, [M("div", {
      class: `${w}-catalog-indicator`,
      style: x.value
    }, null), M("div", {
      class: `${w}-catalog-container`
    }, [S.value.map((l) => M(Q, {
      mdHeadingId: e.mdHeadingId,
      tocItem: l,
      key: `link-${l.level}-${l.text}`,
      onActive: D,
      onClick: (o, f) => {
        e.onClick?.(o, f), t.emit("onClick", o, f);
      },
      scrollElementOffsetTop: e.scrollElementOffsetTop
    }, null))])])]);
  }
});
W.install = (e) => (e.component(W.name, W), e);
export {
  W as M,
  ve as a,
  ge as s
};
